package scanner;

import java_cup.runtime.*;
import java.io.FileReader;
import java.util.ArrayList;
import java.util.List;
import java_cup.runtime.XMLElement;

/* Codigo del parser, manejo de errores. */
parser code {:
    private int contadorErrores = 0;
    private ArrayList<String> errores = new ArrayList<String>();

    @Override
    public void syntax_error(Symbol cur_token){
        try{
            //System.err.println("Error de sintaxis en el token: " + cur_token.value.toString() + ".");
            reportar_error("Error de sintaxis en token " + cur_token.value.toString() + ".", cur_token);
        }catch(Exception E){}
    }
    @Override
    public void unrecovered_syntax_error(Symbol cur_token){
        if(cur_token == null || cur_token.value == null) { //No se encontró token END
            reportar_error("Error fatal de sintaxis al final del programa.", null);
        }
        else { //Por si acaso
            reportar_error("Error fatal de sintaxis en " + cur_token.value.toString(), cur_token);
        }
        
    }

    public void imprimirErrores() {
        System.out.println("\nErrores sintácticos: ");
        for (String error : errores) {
            System.out.println(error);
        }
        //System.out.println(errores.size());
    }

    public void reportar_error(String message, Object info) {
        contadorErrores++;
        StringBuilder m = new StringBuilder("Error #" + contadorErrores);
        if (info instanceof java_cup.runtime.Symbol) {
            java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);
            if (s.left >= 0) {                
                m.append(" en la línea "+(s.left+1));
                if (s.right >= 0)
                    m.append(", columna "+(s.right+1));
            }
        }
        m.append(" : " + message);
        errores.add(m.toString());
        //System.err.println(m);
        //System.out.println(m);
    }
    public void append_error(String message) {
        if (errores.size() != 0) {
            int lastIndex = errores.size() - 1;
            String texto = errores.get(lastIndex);
            errores.set(lastIndex, texto + "\n\t" + message);
        }
        else {
            reportar_error(message, null);
        }
            
    }

    /* Reporte de error encontrado. */
    @Override
    public void report_error(String message, Object info) {
        reportar_error(message, info);
    }
   
    /* Cuando se encuentra un error de donde el sistema no puede
        recuperarse, se lanza un error fatal. Se despliega el mensaje
        de error y se finaliza la ejecución. */
    @Override
    public void report_fatal_error(String message, Object info) {
        report_error(message, info);
        System.exit(1);
    }

    /* Metodo main para garantizar la ejecucion del analizador
       lexico y sintactico, ademas que se pase como parametro la tabla
       de simbolos correspondiente. */
    public static void main(String[] args){
        try {
            //System.out.println("\nResultados finales:");
            Scanner scanner = new Scanner(new FileReader(args[0]));
            Parser parser = new Parser(scanner);
            //Object result = parser.parse().value;
            Symbol parse_tree = null;
            parse_tree = parser.parse();
            scanner.imprimirErrores();
            parser.imprimirErrores();
        } catch (Exception ex) {
            ex.printStackTrace();
        }
    }
:};

/* Terminales y no terminales-------------------------------------*/
/* Terminales----------------------------------------------------- 
   Los terminales que no tienen un valor son listados primero, los terminales que
   tienen un valor como los enteros son listados en la segunda o demas lineas. */
    terminal 
        //Tipos
        TIPO_ARRAY, TIPO_BOOLEAN, TIPO_BYTE, TIPO_CHAR, TIPO_CONST, TIPO_INT,
        TIPO_LONGINT, TIPO_NIL, TIPO_REAL, TIPO_SHORTINT, TIPO_STRING,
        //Palabras reservadas
        PR_BEGIN, PR_CASE,  PR_DO, PR_DOWNTO, PR_ELSE, PR_END, PR_FALSE, 
        PR_FILE, PR_FOR, PR_FORWARD, PR_FUNCTION, PR_GOTO, PR_IF, PR_IN,
        PR_INLINE, PR_LABEL, PR_OF, PR_PACKED, PR_PROCEDURE,  PR_THEN,
        PR_PROGRAM, PR_READ, PR_RECORD, PR_REPEAT, PR_SET, PR_TO, PR_TRUE,
        PR_TYPE, PR_UNTIL, PR_VAR, PR_WHILE, PR_WITH, PR_WRITE,
        //Operadores
        OP_AND, OP_DIV, OP_NOT, OP_MOD, OP_OR, OP_XOR, OP_COMA, SEMI, 
        OP_SUMASUMA, OP_MENOSMENOS, OP_MAYORIGUAL, OP_MAYOR, OP_MENORIGUAL, 
        OP_MENOR, OP_MENORMAYOR, OP_IGUAL, OP_SUMA, OP_RESTA, OP_MULT, 
        OP_DIVISION, PARENTIZQ, PARENTDER, OP_BRACKETIZQ, OP_BRACKETDER, 
        OP_DOSPUNTOSIGUAL, OP_PUNTO, OP_DOSPUNTOS, OP_MASIGUAL, OP_MENOSIGUAL, 
        OP_MULTIGUAL, OP_DIVIGUAL, OP_MAYORMAYOR, OP_MENORMENOR, 
        OP_MENORMENORIGUAL, OP_MAYORMAYORIGUAL,
        //Identificador
        IDENTIFICADOR;
    terminal Integer    ENTERO;
    terminal Double 	REAL;
    terminal String     STRING;

/* No terminales-------------------------------------------------- 
   Primero se lista los no terminales que tienen un valor Object y despues
   se lista los no terminales que tienen un entero. Un Object se refiere a que
   no tienen tipo, pudiendo ser entero o String. */
    /*non terminal Object     expr_init, expr_list, expr_part;
    non terminal Integer    expr, factor, termino;*/
    non terminal 
        //Declaración inicial
        declaracion_programa,
        //Secciones iniciales
        secciones_opcionales,
        tipo, array,
        seccion_constantes, seccion_constantes1, declaracion_constante,
            declaracion_constante1,
        seccion_globales, seccion_globales1, declaracion_global, 
            declaracion_global1, declaracion_global2,
        seccion_funciones, parametros, parametros1, retorno,
            function, function1,
            procedure, procedure1, 
        //Cuerpo del programa
        seccion_instrucciones
        ;

/* Precedencia y asociación de terminales-------------------------*/
precedence left PR_BEGIN, PR_END;
precedence left ENTERO, REAL, STRING;
precedence left OP_AND, OP_OR;
precedence left OP_RESTA, OP_SUMA, OP_MULT, OP_MULT, OP_DIV;
precedence left PARENTIZQ, PARENTDER;
precedence left SEMI;
precedence left IDENTIFICADOR;

/* Gramática------------------------------------------------------*/
    start with declaracion_programa;  

    declaracion_programa ::= PR_PROGRAM IDENTIFICADOR PR_BEGIN seccion_instrucciones PR_END
        | PR_PROGRAM IDENTIFICADOR secciones_opcionales PR_BEGIN seccion_instrucciones PR_END
        //Errores
        | PR_PROGRAM IDENTIFICADOR:id error:e PR_BEGIN:begin seccion_instrucciones PR_END
            {: //Secciones opcionales
                parser.reportar_error("Error en sección de declaraciones", e);
            :}
        | PR_PROGRAM IDENTIFICADOR secciones_opcionales PR_BEGIN error:e PR_END:end
            {: //Secciones de instrucciones
                parser.reportar_error("Error en sección de instrucciones", end);
            :}
        | PR_PROGRAM IDENTIFICADOR PR_BEGIN error:e PR_END:end
            {: //Secciones de instrucciones
                parser.reportar_error("Error en sección de instrucciones", e);
            :}
        ;
    // Secciones opcionales -------------------------------------------------------
    secciones_opcionales ::= seccion_constantes seccion_globales seccion_funciones
        | seccion_constantes
        | seccion_globales
        | seccion_funciones
        | seccion_constantes seccion_globales
        | seccion_globales seccion_funciones
        | seccion_constantes seccion_funciones;

    // Sección de declaración de constantes----------------------------------------
    seccion_constantes ::= TIPO_CONST seccion_constantes1;

    seccion_constantes1 ::= declaracion_constante
        | declaracion_constante seccion_constantes1
        ;

    declaracion_constante ::= IDENTIFICADOR OP_IGUAL declaracion_constante1 SEMI
        | error:e 
            {: //si no viene un identificador pero sí :
                parser.reportar_error("Error en declaración de constante", e);
            :}
        ;

    declaracion_constante1 ::= STRING | ENTERO | REAL;

    // Sección de declaración de globales----------------------------------------
    seccion_globales ::= PR_VAR seccion_globales1
        ;

    seccion_globales1 ::= declaracion_global 
        | declaracion_global seccion_globales1
        ;

    declaracion_global ::=  IDENTIFICADOR OP_COMA declaracion_global1
        | declaracion_global1
        ;

    declaracion_global1 ::= IDENTIFICADOR OP_DOSPUNTOS declaracion_global2 SEMI
        //Posibles errores
        | IDENTIFICADOR error:e declaracion_global2 SEMI
            {: 
                parser.reportar_error("Instrucción incorrecta", e);
            :}
        | IDENTIFICADOR error:e OP_DOSPUNTOS declaracion_global2 SEMI
            {: //si no viene un identificador pero sí :
                parser.reportar_error("Esperando identificador", e);
            :}
        ;

    declaracion_global2 ::= array | tipo 
        | error:e
            {: 
                parser.reportar_error("Mala declaracion de tipo", e);
            :}
        ;

    // Sección de funciones/procedures-------------------------------------
    seccion_funciones ::= function | procedure
        | function seccion_funciones
        | procedure seccion_funciones
        ;

    function ::= PR_FUNCTION IDENTIFICADOR:id1 function1 IDENTIFICADOR:id2 OP_DOSPUNTOSIGUAL retorno SEMI PR_END
            {: 
                if (!id1.equals(id2)) {
                    parser.reportar_error("Error de nombre de función y valor de retorno", id2);
                }
            :}
        | PR_FUNCTION error:e PR_END
            {: 
                parser.reportar_error("Mala declaracion de función", e);
            :}
        ;

    function1 ::= PARENTIZQ parametros PARENTDER OP_DOSPUNTOS tipo PR_BEGIN seccion_instrucciones
        | PARENTIZQ PARENTDER OP_DOSPUNTOS tipo PR_BEGIN seccion_instrucciones
        | PARENTIZQ parametros PARENTDER OP_DOSPUNTOS tipo PR_BEGIN
        | PARENTIZQ PARENTDER OP_DOSPUNTOS tipo PR_BEGIN;

    procedure ::= PR_PROCEDURE IDENTIFICADOR:id1 procedure1 IDENTIFICADOR:id2 OP_DOSPUNTOSIGUAL retorno SEMI PR_END
            {: 
                if (!id1.equals(id2)) {
                    parser.reportar_error("Error de nombre de procedimiento y valor de retorno", id2);
                }     
            :}
        | PR_PROCEDURE error:e PR_END
            {: 
                parser.reportar_error("Mala declaracion de procedimiento", e);
            :}
        ;

    procedure1 ::= PARENTIZQ parametros PARENTDER PR_BEGIN seccion_instrucciones
        | PARENTIZQ PARENTDER PR_BEGIN seccion_instrucciones
        | PARENTIZQ parametros PARENTDER PR_BEGIN
        | PARENTIZQ PARENTDER PR_BEGIN
        | error:e 
            {: 
                parser.reportar_error("Mala declaracion de procedimiento", e);
            :}
        ;

    retorno ::= IDENTIFICADOR | ENTERO | REAL | STRING;

    parametros ::= IDENTIFICADOR OP_DOSPUNTOS tipo
        | IDENTIFICADOR OP_DOSPUNTOS tipo parametros1
        | error:e
            {: 
                parser.reportar_error("Error en lista de parámetros", e);
            :}
        ;

    parametros1 ::= OP_COMA IDENTIFICADOR OP_DOSPUNTOS tipo
        | OP_COMA IDENTIFICADOR OP_DOSPUNTOS tipo parametros1
        ;

    // Sección de contenido del programa (instrucciones)---------------------------------------
    seccion_instrucciones ::= PR_VAR
        ; 

    tipo ::= TIPO_INT | TIPO_LONGINT | TIPO_SHORTINT | TIPO_CHAR | TIPO_STRING | TIPO_BOOLEAN | TIPO_REAL
        ;
    //ARRAY[1..100] OF STRING
    array ::= TIPO_ARRAY OP_BRACKETIZQ ENTERO OP_PUNTO OP_PUNTO ENTERO OP_BRACKETDER PR_OF tipo
        | TIPO_ARRAY OP_BRACKETIZQ ENTERO OP_BRACKETDER PR_OF tipo;
 

/* 'expr' puede ser una expresion que inicia por numero entero op_suma expr,
  de esa forma se realiza una suma. Tambien puede ser un numero entero, con esto
  se devuelve el valor del entero. En RESULT se almacena el valor de las acciones,
  y se pasa al siguiente nivel de la gramatica.
*/              

   /*expr     ::=  expr:e OP_SUMA factor:f
                {:
                RESULT = new Integer(e.intValue() + f.intValue());
                :}
                |
                expr:e OP_RESTA factor:f
                {:
                RESULT = new Integer(e.intValue() - f.intValue());
                :}
                |
                factor:n
                {:
                RESULT = n; 
                :}
                ;

factor ::=  factor:f OP_MULT termino:e
            {:
            RESULT = new Integer(f.intValue() * e.intValue());
            :}
            |
            termino:t
            {:
            RESULT = t;
            :}
            ;

termino ::=  PARENTIZQ expr:e PARENTDER
              {:
                RESULT = e;
              :}
              |
              ENTERO:e
              {:
                RESULT = e;
              :}
              ; */